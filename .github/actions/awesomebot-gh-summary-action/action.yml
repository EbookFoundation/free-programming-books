# ==============================================================================
# AwesomeBot Markdown Summary Report Generator
# 
# Purpose: Generates formatted Markdown reports from AwesomeBot URL checking results
# Input: JSON files containing URL validation results  
# Output: Formatted Markdown summary for GitHub Actions
# Author: GitHub Actions Workflow
# ==============================================================================

name: 'AwesomeBot Markdown Summary Report'
description: 'Composes the summary report using JSON results of any AwesomeBot execution'

inputs:
  ab-root:
    description: 'Path where AwesomeBot result files are written.'
    required: true
  files:
    description: 'A delimited string containing the filenames to process.'
    required: true
  separator:
    description: 'Token used to delimit each filename. Default: space character.'
    required: false
    default: ' '
  append-heading:
    description: 'When true, appends report heading to output. Default: false.'
    required: false
    default: "false"
  write:
    description: 'When true, writes the report to GITHUB_STEP_SUMMARY file. Default: true.'
    required: false
    default: "true"

outputs:
  text:
    description: 'Generated Markdown text content.'
    value: ${{ steps.generate.outputs.text }}

runs:
  using: "composite"

  steps:

    - name: Generate markdown report
      id: generate
      shell: pwsh
      # Security: Sanitize inputs using environment variables
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}
        GITHUB_WORKSPACE: ${{ github.workspace }}
        # INPUT_<VARIABLE_NAME> is not available in Composite run steps
        # Reference: https://github.community/t/input-variable-name-is-not-available-in-composite-run-steps/127611
        INPUT_AB_ROOT: ${{ inputs.ab-root }}
        INPUT_FILES: ${{ inputs.files }}
        INPUT_SEPARATOR: ${{ inputs.separator }}
        INPUT_APPEND_HEADING: ${{ inputs.append-heading }}
      run: |
        # Initialize empty text variable for markdown content
        $text = ""

        # Add optional heading section if requested
        if ("true" -eq $env:INPUT_APPEND_HEADING) {
          $text += "### üìä Report of Checked URLs"
          $text += "`n`n"
          $text += "<div align=`"right`" markdown=`"1`">`n`n"
          $text +=   "_üîó Link validation powered by [``awesome_bot``](https://github.com/dkhamsing/awesome_bot)_"
          $text += "`n`n</div>"
          $text += "`n`n---`n`n"
        }

        # Counter for tracking processed files
        $processedFiles = 0
        $filesWithErrors = 0

        # Process each file from input list
        $env:INPUT_FILES -split $env:INPUT_SEPARATOR | ForEach-Object {
          $file = $_.Trim()
          
          # Skip empty strings and whitespace-only entries
          if ([string]::IsNullOrWhiteSpace($file)) {
            Write-Host "‚ö†Ô∏è  Skipping empty filename"
            return
          }
          
          # Construct result file path by replacing slashes with dashes
          $safeFilename = $file -replace "[/\\]","-"
          $abr_file = $env:INPUT_AB_ROOT + "/ab-results-" + $safeFilename + "-markdown-table.json"

          Write-Host "üìÅ Processing file: $file"
          Write-Host "üîç Looking for result file: $abr_file"

          try {
            # Read and parse JSON results file
            $jsonContent = Get-Content -Path $abr_file -ErrorAction Stop
            $json = $jsonContent | ConvertFrom-Json
            $processedFiles++
            
          } catch [System.IO.FileNotFoundException] {
            # Handle missing file error specifically
            $errorMsg = "‚ùå Result file not found: $abr_file"
            Write-Host $errorMsg
            echo "::warning ::$errorMsg"
            $filesWithErrors++
            return
          } catch {
            # Handle JSON parsing and other errors
            $errorMsg = "‚ùå Error processing file $file : $($_.Exception.Message)"
            Write-Host $errorMsg
            echo "::error ::$errorMsg"
            $filesWithErrors++
            return
          }

          $text += "`n`n"
          
          # Check if file has validation errors
          if ("true" -eq $json.error) {
            $filesWithErrors++
            
            # Regex patterns for highlighting error counts
            $numberSearchPattern = '(?<Num>\d+)'
            $numberReplaceFormat = '**${Num}**'
            
            # Format file entry with error count highlighting
            $text += "`:page_facing_up: **File:** ``" + $file + "``     | ‚ö†Ô∏è  " + ($json.title -replace $numberSearchPattern, $numberReplaceFormat) + "`n"
            
            # Remove awesome_bot attribution to avoid duplication (already in heading)
            $cleanMessage = $json.message -replace "####.*?```n","`n"
            $text += $cleanMessage
          } else {
            # File has no validation issues
            $text += ":page_facing_up: **File:** ``" + $file + "``     | ‚úÖ  **No issues found**`n"
            $text += "> All URLs validated successfully"
          }
        }

        # Add summary section if multiple files processed
        if ($processedFiles -gt 1) {
          $text += "`n`n---`n`n"
          $text += "### üìà Processing Summary`n"
          $text += "- **Total files processed:** $processedFiles`n"
          $text += "- **Files with issues:** $filesWithErrors`n"
          $text += "- **Files without issues:** " + ($processedFiles - $filesWithErrors) + "`n"
        }

        # Set multiline output using random delimiter for security
        # Reference: https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
        $delimiter = "EOF_" + (Get-Random -Maximum 1000000)
        echo "text<<$delimiter" >> $env:GITHUB_OUTPUT
        echo "$text" >> $env:GITHUB_OUTPUT
        echo "$delimiter" >> $env:GITHUB_OUTPUT

        # Log processing completion
        Write-Host "‚úÖ Markdown generation completed: $processedFiles files processed, $filesWithErrors with issues"

    - name: Write output to step summary
      if: ${{ fromJson(inputs.write) }}
      shell: bash
      env:
        INPUT_TEXT: ${{ steps.generate.outputs.text }}
      run: |
        echo "$INPUT_TEXT" >> $GITHUB_STEP_SUMMARY
        echo "üìù Report written to GitHub Step Summary"